#include "synth2/oscillator.h"

#include <assert.h>
#include <math.h>

#define PI 3.141592
#define PI2 (2.0 * (PI))

/// The wave generation function. Accept following arguments.
/// 1. position in one-cycle wave. Must be in [0, 2Ï€).
/// 2. previously sampled value.
/// 3. duty of the wave, but is maybe unused.
typedef double (*wave_generator)(double, double, double);

/// Sample a point from wava generated by gen function, then increase osc->phase.
static inline double sample(synth2_oscillator_t *osc, wave_generator gen) {
    osc->prev = gen(osc->phase, osc->prev, osc->duty);
    osc->phase += PI2 * osc->freq / osc->sample_rate;
    if (osc->phase >= PI2) osc->phase -= PI2;
    return osc->prev;
}

/// Naive method for sine wave generation.
static inline double gen_sine_naive(double x, double prev, double duty) {
    return sin(x);
}

/// Naive method for triangle wave generation.
static inline double gen_triangle_naive(double x, double prev, double duty) {
    return 0.0;
}

/// Naive method for sawtooth wave generation.
static inline double gen_saw_naive(double x, double prev, double duty) {
    return (2.0 * x / PI2) - 1.0;
}

/// Naive method for square wave generation.
static inline double gen_square_naive(double x, double prev, double duty) {
    return x < PI * duty ? 1.0 : -1.0;
}

/// Type alias for sample in synth2_oscillator_t.
typedef double (*sample_cb)(synth2_oscillator_t *);

/// Create a sample cb using gen_sine_naive.
static inline double sample_sine_naive(synth2_oscillator_t *osc) {
    return sample(osc, gen_sine_naive);
}

/// Create a sample cb using gen_triangle_naive.
static inline double sample_triangle_naive(synth2_oscillator_t *osc) {
    return sample(osc, gen_triangle_naive);
}

/// Create a sample cb using gen_saw_naive.
static inline double sample_saw_naive(synth2_oscillator_t *osc) {
    return sample(osc, gen_saw_naive);
}

/// Create a sample cb using gen_square_naive.
static inline double sample_square_naive(synth2_oscillator_t *osc) {
    return sample(osc, gen_square_naive);
}

/// Returns sample cb for sine wave by specified method.
static inline sample_cb get_sample_sine_cb(synth2_oscillator_method_t method) {
    return sample_sine_naive;
}

/// Returns sample cb for triangle wave by specified method.
static inline sample_cb get_sample_triangle_cb(synth2_oscillator_method_t method) {
    return sample_triangle_naive;
}

/// Returns sample cb for saw wave by specified method.
static inline sample_cb get_sample_saw_cb(synth2_oscillator_method_t method) {
    return sample_saw_naive;
}

/// Returns sample cb for square wave by specified method.
static inline sample_cb get_sample_square_cb(synth2_oscillator_method_t method) {
    return sample_square_naive;
}

/// Returns sample cb by specified method and wave.
static inline sample_cb
get_sample_cb(synth2_oscillator_method_t method, synth2_oscillator_wave_t wave) {
    if (wave == SYNTH2_OSC_WAVE_SINE) {
        return get_sample_sine_cb(method);
    } else if (wave == SYNTH2_OSC_WAVE_TRIANGLE) {
        return get_sample_triangle_cb(method);
    } else if (wave == SYNTH2_OSC_WAVE_SAW) {
        return get_sample_saw_cb(method);
    } else {
        return get_sample_square_cb(method);
    }
}

void synth2_oscillator_init(
    synth2_oscillator_t *osc,
    synth2_oscillator_method_t method,
    synth2_oscillator_wave_t wave,
    double sample_rate,
    double freq,
    double duty
) {
    assert(method == SYNTH2_OSC_METHOD_NAIVE);

    osc->sample_rate = sample_rate;
    osc->freq = freq;
    osc->phase = 0.0;
    osc->duty = duty;
    osc->prev = 0.0;
    osc->sample = get_sample_cb(method, wave);
}
